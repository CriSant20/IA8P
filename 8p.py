# -*- coding: utf-8 -*-
"""8 puzzle.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NmqlJ8E2D0YBzoNjYj8dpqNYyP9gjWly
"""

# -*- coding: utf-8 -*-
"""ocho estrella rectificado.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JJilhbaP45M1zGfBMFOZwZLHu66VEese
"""
import heapq
import time
import psutil
import random

class Nodo:
    def __init__(self, estado, padre=None, accion=None, costo_g=0, costo_h=0):
        self.estado = estado
        self.padre = padre
        self.accion = accion
        self.costo_g = costo_g
        self.costo_h = costo_h

    def costo_total(self):
        return self.costo_g + self.costo_h

    def __lt__(self, otro):
        return self.costo_total() < otro.costo_total()

    def obtener_matriz_estado(self):
        return [list(fila) for fila in self.estado]

    def imprimir_estado(self):
        for fila in self.estado:
            print(fila)
        print()

class Operaciones:

    def calcular_costo_h(self, estado, estado_objetivo):
        fichas_mal_ubicadas = 0
        for i in range(3):
            for j in range(3):
                if estado[i][j] != estado_objetivo[i][j]:
                    fichas_mal_ubicadas += 1
        return fichas_mal_ubicadas

    def calcular_costo_g(self,nodo):
        return nodo.costo_g + 1

class Cola():
    # uso de colas de prioridad

    def __init__(self):
        self.cola = []

    def cola_vacia(self):
        return len(self.cola) == 0

    def sacar_elemento(self):
        return heapq.heappop(self.cola)
    #
    def agregar_elemento(self, elemento):
        heapq.heappush(self.cola, elemento)

class Resolver:
    def __init__(self, estado_objetivo=None):
        self.estado_inicial = self.generar_estado_inicial()
        self.estado_objetivo = estado_objetivo if estado_objetivo else [[0, 1, 2], [3, 4, 5], [6, 7, 8]]

    def obtener_acciones_posibles(self, estado):
        acciones_posibles = []
        fila_vacio = None
        columna_vacio = None
        for i in range(3):
            for j in range(3):
                if estado[i][j] == 0:
                    fila_vacio = i
                    columna_vacio = j
                    break
            if fila_vacio is not None:
                break

        if fila_vacio > 0:
            acciones_posibles.append('abajo')
        if fila_vacio < 2:
            acciones_posibles.append('arriba')
        if columna_vacio > 0:
            acciones_posibles.append('derecha')
        if columna_vacio < 2:
            acciones_posibles.append('izquierda')

        return acciones_posibles

    def es_estado_objetivo(self, estado):
        return estado == self.estado_objetivo

    def funcion_sucesor(self,movimientos,nodo_padre):
        sucesores = []
        calculo = Operaciones()
        for accion in movimientos:
            estado_nuevo = nodo_padre.obtener_matriz_estado()
            fila_vacio = None
            columna_vacio = None

            for i in range(3):
                for j in range(3):
                    if estado_nuevo[i][j] == 0:
                        fila_vacio = i
                        columna_vacio = j
                        break
                if fila_vacio is not None:
                    break

            if accion == 'abajo':
                estado_nuevo[fila_vacio][columna_vacio], estado_nuevo[fila_vacio - 1][columna_vacio] = estado_nuevo[fila_vacio - 1][columna_vacio], estado_nuevo[fila_vacio][columna_vacio]
            elif accion == 'arriba':
                estado_nuevo[fila_vacio][columna_vacio], estado_nuevo[fila_vacio + 1][columna_vacio] = estado_nuevo[fila_vacio + 1][columna_vacio], estado_nuevo[fila_vacio][columna_vacio]
            elif accion == 'derecha':
                estado_nuevo[fila_vacio][columna_vacio], estado_nuevo[fila_vacio][columna_vacio - 1] = estado_nuevo[fila_vacio][columna_vacio - 1], estado_nuevo[fila_vacio][columna_vacio]
            elif accion == 'izquierda':
                estado_nuevo[fila_vacio][columna_vacio], estado_nuevo[fila_vacio][columna_vacio + 1] = estado_nuevo[fila_vacio][columna_vacio + 1], estado_nuevo[fila_vacio][columna_vacio]

            costo_g_nuevo = calculo.calcular_costo_g(nodo_padre)
            costo_h_nuevo = calculo.calcular_costo_h(estado_nuevo, self.estado_objetivo)
            nodo_nuevo = Nodo(estado_nuevo, nodo_padre, accion, costo_g_nuevo, costo_h_nuevo)
            sucesores.append(nodo_nuevo)
        return sucesores


    def generar_estado_inicial(self):
        numeros = list(range(9))
        random.shuffle(numeros)
        estado_inicial = [[numeros[i * 3 + j] for j in range(3)] for i in range(3)]
        return estado_inicial
    def imprimir_pasos(self, nodo):
        pasos = []
        while nodo.accion is not None:
            pasos.append(nodo.accion)
            nodo = nodo.padre
        pasos.reverse()
        estado_actual = self.estado_inicial
        for i, paso in enumerate(pasos, start=1):
            print("Paso {}: mover {}".format(i, paso))
            if paso == 'arriba':
                estado_actual = self.mover_arriba(estado_actual)
            elif paso == 'abajo':
                estado_actual = self.mover_abajo(estado_actual)
            elif paso == 'izquierda':
                estado_actual = self.mover_izquierda(estado_actual)
            elif paso == 'derecha':
                estado_actual = self.mover_derecha(estado_actual)
            for fila in estado_actual:
                print(fila)
            print()

    def mover_arriba(self, estado):
        estado_nuevo = estado.copy()
        fila_vacio = None
        columna_vacio = None
        for i in range(3):
            for j in range(3):
                if estado_nuevo[i][j] == 0:
                    fila_vacio = i
                    columna_vacio = j
                    break
            if fila_vacio is not None:
                break
        estado_nuevo[fila_vacio][columna_vacio], estado_nuevo[fila_vacio + 1][columna_vacio] = estado_nuevo[fila_vacio + 1][columna_vacio], estado_nuevo[fila_vacio][columna_vacio]
        return estado_nuevo

    def mover_abajo(self, estado):
        estado_nuevo = estado.copy()
        fila_vacio = None
        columna_vacio = None
        for i in range(3):
            for j in range(3):
                if estado_nuevo[i][j] == 0:
                    fila_vacio = i
                    columna_vacio = j
                    break
            if fila_vacio is not None:
                break
        estado_nuevo[fila_vacio][columna_vacio], estado_nuevo[fila_vacio - 1][columna_vacio] = estado_nuevo[fila_vacio - 1][columna_vacio], estado_nuevo[fila_vacio][columna_vacio]
        return estado_nuevo

    def mover_izquierda(self, estado):
        estado_nuevo = estado.copy()
        fila_vacio = None
        columna_vacio = None
        for i in range(3):
            for j in range(3):
                if estado_nuevo[i][j] == 0:
                    fila_vacio = i
                    columna_vacio = j
                    break
            if fila_vacio is not None:
                break
        estado_nuevo[fila_vacio][columna_vacio], estado_nuevo[fila_vacio][columna_vacio + 1] = estado_nuevo[fila_vacio][columna_vacio + 1], estado_nuevo[fila_vacio][columna_vacio]
        return estado_nuevo

    def mover_derecha(self, estado):
        estado_nuevo = estado.copy()
        fila_vacio = None
        columna_vacio = None
        for i in range(3):
            for j in range(3):
                if estado_nuevo[i][j] == 0:
                    fila_vacio = i
                    columna_vacio = j
                    break
            if fila_vacio is not None:
                break
        estado_nuevo[fila_vacio][columna_vacio], estado_nuevo[fila_vacio][columna_vacio - 1] = estado_nuevo[fila_vacio][columna_vacio - 1], estado_nuevo[fila_vacio][columna_vacio]
        return estado_nuevo
    def Resolver_8_puzzle(self):
        estado_inicial = self.estado_inicial

        estado_objetivo = self.estado_objetivo
        visitados = set()
        cola = Cola()

        nodo_inicio = Nodo(estado_inicial)
        cola.agregar_elemento((0, nodo_inicio))
        print("------------------------")
        print("Estado inicial:")
        nodo_inicio.imprimir_estado()
        start_time = time.time()
        max_ram = 0

        while not cola.cola_vacia():
            _, nodo_actual = cola.sacar_elemento()
            estado_actual = nodo_actual.estado
            if self.es_estado_objetivo(estado_actual):
                print("Estado final:")
                nodo_actual.imprimir_estado()
                print("Tiempo transcurrido: {:.6f} segundos".format(time.time() - start_time))
                print("Cantidad de memoria utilizada: {} bytes".format(psutil.virtual_memory().used))
                print("------------*-----------")
                print("*** Pasos para resolver el puzzle ***")
                self.imprimir_pasos(nodo_actual)
                return

            visitados.add(tuple(map(tuple, estado_actual)))

            acciones_posibles = self.obtener_acciones_posibles(estado_actual)
            sucesores = self.funcion_sucesor(acciones_posibles, nodo_actual)
            for sucesor in sucesores:
                if tuple(map(tuple, sucesor.estado)) not in visitados:
                    cola.agregar_elemento((sucesor.costo_total(), sucesor))

            max_ram = max(max_ram, psutil.virtual_memory().used)

        print("No se encontró solución.")
        print("Tiempo transcurrido: {:.6f} segundos".format(time.time() - start_time))
        print("Cantidad máxima de memoria utilizada: {} bytes".format(max_ram))

estado_objetivo_personalizado = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]
resolver = Resolver(estado_objetivo_personalizado)
resolver.Resolver_8_puzzle()